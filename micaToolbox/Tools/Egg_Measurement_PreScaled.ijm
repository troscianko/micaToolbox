/*
_______________________________________________________________________

	Title: Egg Measuring Tool
	Author: Jolyon Troscianko
	Date: 15/04/13
	23/04/13 - added volume, surface area & other measurements
.................................................................................................................

Description:
''''''''''''''''''''''''''''''''
This code uses a custom mathematical model of egg shapes that is based on an
elipse deformed with a distribution function. In testing it fits the shape of all eggs
I've managed to find, and the model reflects the egg shaping process that occurs
in the oviduct of the bird.

The code then calculates the length, width, volume, surface area and "pointiness"
of the egg, all values scaled from the user's selection of a scale bar.

The "pointedness" value is generated by calculating the deviation of the egg's shape from
an ellipse of the same height (based on sum-of-squares). A higher number implies the
egg deviates from an ellipse more, making it more pointy.

Area is calculated from a series of trapezia, so while not exact, it comes up with the
same numbers for a sphere surface area as the true mathematical value. Likewise,
volume is measured from a series of cylindrical cross-sections, making the assumption
that the cross-section of the egg is round. The number of segments can be increased
to improve precision, but a value of 10,000 is more than sufficient.

Instructions:
''''''''''''''''''''''''''''''''''''''''
To install, place this file in: ImageJ/plugins/Egg Measurement/. And restart ImageJ or go
help>refresh menus.

Photograph eggs side-on with a scale bar/ruler raised to the centre of the egg so that
the scale bar is the same distance from the camera as the edge of the egg. Also make
sure your lens does not have significant lens distortion (take a photo of some graph paper
and if the lines on the paper curve then your lens is distorting the image). Lens distortion
can be eliminated using various bits of software. Once distortion is corrected/ignored the
image can be used for making measurements.

Open your photo and use the multipoint tool to select the tip and base of the egg. Then
select a number of other points around the edge of the egg. I find that the 8 points
of a compass bearing are good to use for most eggs. Run the code and click "accept"
to accept the egg shape model, or "adjust" if you want to drag the points around to
increase accuracy, or add more points around the edge.

When prompted draw a line along a section of your scale bar of a known length. The longer
the length you can select the better from a precision point-of-view. You will the be asked to
input the length of the scale you just selected. This is used to scale all the values of length/
width/volume/surface-area. If you scale bar was in millimeters your volume measurements will
be in cubic millimeters, and surface area in millimeters squared.

_________________________________________________________________________
*/


Dialog.create("Egg ID");
	Dialog.addNumber("Egg_Number", 1);
Dialog.show();

eggID = Dialog.getNumber();


//run("Set Measurements...", "area mean min scientific redirect=None decimal=9"); // record scientific measurements (maximum precision)
modelPoints = 10000; //number of points to model on each side of the egg - higher will increase precision but slow processing

Overlay.remove;

imageID = getImageID();

getSelectionCoordinates(xCoords, yCoords);

maxDist = 0;

for(i=0; i<xCoords.length; i++){
	for(j=0; j<xCoords.length; j++){
		distance = pow(pow(xCoords[i]-xCoords[j],2)+pow(yCoords[i]-yCoords[j],2),0.5);
		if(distance>maxDist){
			maxDist = pow(pow(xCoords[i]-xCoords[j],2)+pow(yCoords[i]-yCoords[j],2),0.5);
			aFurthest = i;
			bFurthest = j;
		}
	}
}

xAnchor = xCoords[aFurthest];
yAnchor = yCoords[aFurthest];
xAnchorEnd = xCoords[bFurthest];
yAnchorEnd = yCoords[bFurthest];
if(yCoords[bFurthest]<yCoords[aFurthest]){
	xAnchor = xCoords[bFurthest]; // set anchor to the largest y-value
	yAnchor = yCoords[bFurthest];
	xAnchorEnd = xCoords[aFurthest];
	yAnchorEnd = yCoords[aFurthest];
}

eggGrad = (yAnchorEnd-yAnchor)/(xAnchorEnd-xAnchor);
eggInter1 = yAnchor - (eggGrad*xAnchor);//b
eggInter2 = yAnchorEnd - (eggGrad*xAnchorEnd);//g
eggInter = (eggInter1+eggInter2)/2; // averaged due to rounding errors

residGrad = -1/eggGrad;

residCentreX = newArray(xCoords.length); //distance from aFurthest
residCentreY = newArray(xCoords.length); //distance from central line (residuals), all positive

for(i=0; i<xCoords.length; i++){
	residInter = yCoords[i] - (residGrad*xCoords[i]); //intercept of residual line
	residCentreX[i] = -(residInter-eggInter)/(residGrad-eggGrad);
	residCentreY[i] = residCentreX[i] *residGrad + residInter;
}


//PLOTTING:

setColor(200,0,0);
setLineWidth(0.5);
Overlay.drawLine(xAnchor,yAnchor,xAnchorEnd,yAnchorEnd);
for(i=0; i<xCoords.length; i++)
	Overlay.drawLine(xCoords[i],yCoords[i],residCentreX[i],residCentreY[i]);

Overlay.show;

// MODELLING EGG SHAPE: 

eggLength = pow(pow(xCoords[bFurthest]-xCoords[aFurthest],2)  + pow(yCoords[bFurthest]-yCoords[aFurthest],2),0.5);

// add initial points (the distance from the anchor ot the anchor)

rightEggXvals = newArray(eggLength, 0); // distance from end of egg to intercept on the central line (e.g. like a regression)
rightEggYvals = newArray(0,0); // distance from centre line of egg to point (e.g. like a residual)
leftEggXvals = newArray(eggLength, 0);
leftEggYvals = newArray(0,0);


for(i=0; i<xCoords.length; i++){

	if(i != aFurthest){// makes sure the two end points aren't included
	if(i != bFurthest){


	if(residCentreX[i]<=xCoords[i]){ //right egg distances from end of egg and central regression line
		rightEggXvals = Array.concat(rightEggXvals, pow(pow(residCentreX[i]-xAnchor,2)  + pow(residCentreY[i]-yAnchor,2),0.5)   );
		rightEggYvals = Array.concat(rightEggYvals, pow(pow(residCentreX[i]-xCoords[i],2)  + pow(residCentreY[i]-yCoords[i],2),0.5)   );
	}

	if(residCentreX[i]>=xCoords[i]){ //left egg
		leftEggXvals = Array.concat(leftEggXvals, pow(pow(residCentreX[i]-xAnchor,2)  + pow(residCentreY[i]-yAnchor,2),0.5)   );
		leftEggYvals = Array.concat(leftEggYvals, pow(pow(residCentreX[i]-xCoords[i],2)  + pow(residCentreY[i]-yCoords[i],2),0.5)   );
	}

	}// if b
	}// if a
}


// FITTING EGG SHAPE MODEL

eggEquation = "y= (a*EXP(-1*((x*x)/(2*b*b))+((c*x)/(b*b))-((c*c)/(2*b*b)))*pow(1-x,0.5)*pow(x,0.5))/("+PI+"*b) "; //this is the equation if the length of the egg=1

guesses = newArray(5,1,0.5);


rightEggXvalsProp = newArray(rightEggXvals.length); // values scaled down so length = 1 (this makes the model formula more simple & easy to fit from initial values)
rightEggYvalsProp = newArray(rightEggXvals.length);
leftEggXvalsProp = newArray(leftEggXvals.length);
leftEggYvalsProp = newArray(leftEggXvals.length);

for(i=0; i<rightEggXvals.length; i++){
	rightEggXvalsProp[i] = rightEggXvals[i]/eggLength;
	rightEggYvalsProp[i] = rightEggYvals[i]/eggLength;
}

for(i=0; i<leftEggXvals.length; i++){
	leftEggXvalsProp[i] = leftEggXvals[i]/eggLength;
	leftEggYvalsProp[i] = leftEggYvals[i]/eggLength;
}


// GENERATING SELECTION COORDINATES:

// FITTING RIGHT EGG:
Fit.doFit(eggEquation, rightEggXvalsProp, rightEggYvalsProp, guesses);

rA = Fit.p(0);
rB = Fit.p(1);
rC = Fit.p(2);

rightR2 = Fit.rSquared;
rightModelX = newArray(modelPoints+1);
rightModelY = newArray(modelPoints+1);
rightRadius = newArray(modelPoints+1); //for use in volume calculations later
eggX = newArray(modelPoints+1); //for use in volume calculations later

for(i=0; i<modelPoints+1; i++){
	rightModelX[i] = i/modelPoints; // 0 to 1
	rightModelY[i] = Fit.f(i/modelPoints);
	rightRadius[i]=Fit.f(i/modelPoints);
	eggX[i] = i/modelPoints;
}

// FITTING LEFT EGG
Fit.doFit(eggEquation, leftEggXvalsProp, leftEggYvalsProp, guesses);

lA = Fit.p(0);
lB = Fit.p(1);
lC = Fit.p(2);

leftR2 = Fit.rSquared;
leftModelX = newArray(modelPoints+1);
leftModelY = newArray(modelPoints+1);
leftRadius = newArray(modelPoints+1); //for use in volume calculations later

for(i=0; i<modelPoints+1; i++){
	leftModelX[modelPoints-i] = i/modelPoints; // 1 to 0 (so they can be connected later)
	leftModelY[modelPoints-i] = Fit.f(i/modelPoints);
	leftRadius[i]=Fit.f(i/modelPoints);
}



//TRANSFORMING MODEL BACK TO PIXELS:


if(eggGrad<0)
	eggAngle = atan(-eggGrad);
if(eggGrad>0)
	eggAngle = atan(-eggGrad)+PI;


// rotate & scale the model fits
for(i=0; i<modelPoints+1; i++){

	x = rightModelX[i]; // right egg
	y = rightModelY[i];
	rightModelX[i] = xAnchor-(x*cos(eggAngle)-y*sin(eggAngle)) * eggLength;
	rightModelY[i] = (x*sin(eggAngle)+y*cos(eggAngle)) * eggLength + yAnchor;

	x = leftModelX[i]; // left egg
	y = leftModelY[i];
	leftModelX[i] = xAnchor-(x*cos(eggAngle)+y*sin(eggAngle)) * eggLength;
	leftModelY[i] = (x*sin(eggAngle)- y*cos(eggAngle)) * eggLength + yAnchor;
}//i



allPointsX = Array.concat(rightModelX, leftModelX);
allPointsY = Array.concat(rightModelY, leftModelY);


selectImage(imageID);

makeSelection("freeline", allPointsX, allPointsY);
//makeSelection("polygon ", allPointsX, allPointsY);
//makeSelection("polyline ", allPointsX, allPointsY);


//MOUSE SELECTION

// Button variables:

Array.getStatistics(allPointsX, xMin, xMax, xMean, xStdv);
Array.getStatistics(allPointsY, yMin, yMax, yMean, yStdv);

//buttonScaler = getWidth()/500;
buttonScaler = eggLength/250;

b1X = xMin;
b1Y=yMax;
b1W = 35 * buttonScaler;
b1H=20 *buttonScaler; //(this will be doubled)



b2X = b1X + b1W + b1H + 5;
b2Y = b1Y;
b2W = b1W;
b2H = b1H;

b1Y=b1Y+b1H; // shift the y coordinate to match line width
b2Y=b2Y+b2H;


setColor(0,0,0);
setLineWidth(b1H);
Overlay.drawLine(b1X,b1Y,b1X+b1W,b1Y);
Overlay.drawLine(b2X,b2Y,b2X+b2W,b2Y);
Overlay.show;

setColor(200,200,200);
setFont("SansSerif", round(10*buttonScaler));
Overlay.drawString("Accept", b1X, b1Y + round(5*buttonScaler));
Overlay.drawString("Adjust", b2X, b2Y + round(5*buttonScaler));
Overlay.show;

//MOUSE SELECTION

      if (getVersion>="1.37r")
          setOption("DisablePopupMenu", true);

	leftButton=16;
	clicked=0;
	tool2=0;


      while (clicked==0) {
 	getCursorLoc(x, y, z, flags);

		// switch mouse pointer while over the buttons:
		if (x>b1X &&  y>b1Y-b1H && x<b1X+b1W && y<b1Y+b1H)
			tool=1;
			//setTool("hand");
		else if (x>b2X &&  y>b2Y-b2H && x<b2X+b2W && y<b2Y+b2H)
			tool=1;
			//setTool("hand");
		else
			tool=0;
			//setTool("multipoint");

		if(tool != tool2)
			if(tool == 0)
				setTool("multipoint");
			if(tool == 1)
				setTool("hand");
		tool2=tool;


	// if button is clicked:
	if (flags&leftButton!=0){
		if (x>b1X &&  y>b1Y-b1H && x<b1X+b1W && y<b1Y+b1H)
			clicked=1; // button 1 clicked
		if (x>b2X &&  y>b2Y-b2H && x<b2X+b2W && y<b2Y+b2H)
			clicked=2; // button 2 clicked
	}
          wait(10);
      }
      if (getVersion>="1.37r")
          setOption("DisablePopupMenu", false);

setTool("multipoint");
Overlay.remove();

// READJUST POSITIONS
if(clicked == 2) // adjust positons
	makeSelection("point", xCoords, yCoords);


// FIT ACCEPTED
if(clicked == 1){

	//if(eggID == 1){
		row = nResults;
		setResult("Label", row, getTitle + "_egg" + eggID);
	//} else row = nResults - 1;
	makeSelection("polygon", allPointsX, allPointsY);
	getStatistics(area, mean, min, max, std);

	//setResult("Label", row, File.name);
	setResult("Area (px)", row, area);

run("Select None");

// check whether there's already a scale bar

nSelections = roiManager("count");

scaleFlag = 0;
saveAnchors = 0;

for(j=0; j<nSelections; j++){
	roiManager("select", j);
	selName = getInfo("selection.name");

	if( startsWith(selName, "Scale") == 1){ // found the scale bar - extract the info
		scaleLoc = j;
		scaleFlag = scaleFlag+1;
		scaleInfo = split(selName, ":");
		pxLength = parseFloat(scaleInfo[1]);
		mmLength = parseFloat(scaleInfo[2]);
	}
		
}

if(scaleFlag == 0){ // no scale bar pre-selected, open manual input

setTool("line");
makeLine(xCoords[aFurthest], yCoords[aFurthest], xCoords[bFurthest], yCoords[bFurthest]);
waitForUser("Scale Bar","Draw a line a known distance along the scale bar\nOr click OK if you know the exact egg length");
getSelectionCoordinates(scaleXcoords, scaleYcoords);
pxLength = pow(pow(scaleXcoords[0]-scaleXcoords[1],2) + pow(scaleYcoords[0]-scaleYcoords[1],2),0.5); //pythagorean legth
//print(pxLength);

Dialog.create("Scale bar");
	Dialog.addNumber("How long is the selected scale?", 1);
	Dialog.addMessage("Subsequent measurements will use the same units e.g. mm\n ");
Dialog.show();

mmLength = Dialog.getNumber();

letter = "Scale Bar:" + pxLength + ":" + mmLength;

roiManager("Add");
nSelections = roiManager("count");
roiManager("select", nSelections-1);
roiManager("Rename", letter);

roiManager("Set Color", "red");
roiManager("Show All");
run("Labels...", "color=white font=12 show use draw");



}

pxPermm = pxLength/mmLength;
eggLengthmm = eggLength / pxPermm;
setResult("Length", row, eggLengthmm);

// VOLUME CALCULATION

sliceThickness = 1/(modelPoints+1); // the height of each slice through the egg
volumeSum = 0;
radiusArray = newArray(modelPoints+1);
maxRadius = 0;

for(i=0; i<modelPoints+1; i++){
	sliceRadius = (leftRadius[i] + rightRadius[i])/2; // radius assumed to be the average of the two egg model sides, with a round cross-section
	radiusArray[i] = sliceRadius;
	sliceVolume = PI*(sliceRadius*sliceRadius)*sliceThickness; // volume of a cylinder: pi * r^2 * h
	volumeSum = volumeSum + sliceVolume;
	if(sliceRadius > maxRadius)
		maxRadius = sliceRadius;
}

setResult("Max Width", row, (maxRadius*2)* eggLengthmm);

volumeSum = volumeSum*pow(eggLengthmm,3);
setResult("Volume", row, volumeSum);


// DEVIATION FROM AN ELLIPSE - a measure of how "pointy" an egg is, the higher the deviation from an ellipse, the more pointy
ellipseArray = newArray(modelPoints+1);
ellipseDeviation = 0;

for(i=0; i<modelPoints+1; i++){
	ellipseArray[i] = maxRadius*(2*pow(1-(i/modelPoints),0.5)*pow(i/modelPoints,0.5));
	ellipseDeviation = ellipseDeviation + pow(ellipseArray[i] - radiusArray[i],2); // sum of squares
}


setResult("Ellipse Deviation", row, ellipseDeviation/(modelPoints+1)); // pointiness value

// SURFACE AREA CALCULATION

cosTheta = cos((2*PI)/modelPoints);
areaSum = 0;

for(i=0; i<modelPoints; i++){
	L1 = pow( (2*pow(radiusArray[i],2)) - (2*radiusArray[i]*radiusArray[i]*cosTheta) ,0.5); // law of cosines
	L2 = pow( (2*pow(radiusArray[i+1],2)) - (2*radiusArray[i+1]*radiusArray[i+1]*cosTheta) ,0.5); // law of cosines
	//L1 = (2*PI*radiusArray[i])/modelPoints;
	//L2 = (2*PI*radiusArray[i+1])/modelPoints;

	trapH = pow(pow(1/(modelPoints+1),2)+pow(radiusArray[i]-radiusArray[i+1],2),0.5);   // trapezium height using pythag.
	trapArea = 0.5*trapH*(L1+L2); // area of a trapezium
	areaSum = areaSum + (trapArea*modelPoints); // sum all of the trapezium areas
}
setResult("Surface Area", row, areaSum*pow(eggLengthmm,2));
setResult("Left Fit", row, leftR2);
setResult("Right Fit", row, rightR2);

setResult("Shape A", row, (lA + rA)/2);
setResult("Shape B", row, (lB + rB)/2);
setResult("Shape C", row, (lC + rC)/2);

// SAVE SELECTION COORDINATES AS ROI FILE


makeSelection("polygon ", allPointsX, allPointsY);

setTool("multipoint");


}// fit accepted




